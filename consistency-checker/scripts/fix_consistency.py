#!/usr/bin/env python3
"""
Consistency Fixer - Auto-fix Script
Automatically fixes consistency issues where safe to do so.
"""
import os
import sys
import shutil
from pathlib import Path
from typing import List, Dict
import json


class ConsistencyFixer:
    """Fix common consistency issues automatically."""
    
    def __init__(self, root_dir: str, auto_fix: bool = False):
        self.root_dir = Path(root_dir).resolve()
        self.auto_fix = auto_fix
        self.fixes_applied = []
        self.manual_actions = []
        
    def fix_all(self):
        """Apply all safe automatic fixes."""
        print(f"üîß Fixing consistency issues in {self.root_dir}...")
        
        self.fix_gitignore()
        self.consolidate_requirements()
        self.create_env_example()
        
        self.print_summary()
    
    def fix_gitignore(self):
        """Ensure .gitignore has essential entries."""
        gitignore_path = self.root_dir / ".gitignore"
        
        essential_patterns = [
            "# Environment",
            ".env",
            ".env.local",
            "",
            "# Python",
            "__pycache__/",
            "*.py[cod]",
            "*$py.class",
            "*.so",
            ".Python",
            "venv/",
            "env/",
            "ENV/",
            "",
            "# Node",
            "node_modules/",
            "npm-debug.log*",
            "",
            "# IDE",
            ".vscode/",
            ".idea/",
            "*.swp",
            "*.swo",
            "*~",
            "",
            "# OS",
            ".DS_Store",
            "Thumbs.db",
            "",
            "# Build",
            "build/",
            "dist/",
            "*.egg-info/",
        ]
        
        if not gitignore_path.exists():
            if self.auto_fix or self._confirm("Create .gitignore with essential patterns?"):
                with open(gitignore_path, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(essential_patterns))
                self.fixes_applied.append("‚úÖ Created .gitignore with essential patterns")
            else:
                self.manual_actions.append("üìù Manually create .gitignore file")
        else:
            with open(gitignore_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check for essential patterns
            missing_patterns = []
            for pattern in [".env", "__pycache__", "*.pyc", "node_modules"]:
                if pattern not in content:
                    missing_patterns.append(pattern)
            
            if missing_patterns:
                if self.auto_fix or self._confirm(f"Add missing patterns to .gitignore? {missing_patterns}"):
                    with open(gitignore_path, 'a', encoding='utf-8') as f:
                        f.write('\n\n# Added by consistency checker\n')
                        f.write('\n'.join(missing_patterns))
                    self.fixes_applied.append(f"‚úÖ Added {len(missing_patterns)} patterns to .gitignore")
                else:
                    self.manual_actions.append(f"üìù Manually add patterns to .gitignore: {missing_patterns}")
    
    def consolidate_requirements(self):
        """Consolidate multiple requirements files."""
        req_files = list(self.root_dir.rglob("*requirements*.txt")) + \
                   list(self.root_dir.rglob("*requirement.txt"))
        
        if len(req_files) <= 1:
            return  # Nothing to consolidate
        
        # Collect all requirements
        all_requirements = set()
        root_req = self.root_dir / "requirements.txt"
        
        for req_file in req_files:
            try:
                with open(req_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            all_requirements.add(line)
            except Exception as e:
                print(f"‚ö†Ô∏è  Could not read {req_file}: {e}")
        
        if self.auto_fix or self._confirm(f"Consolidate {len(req_files)} requirements files into one?"):
            # Write consolidated requirements
            with open(root_req, 'w', encoding='utf-8') as f:
                f.write("# Consolidated requirements\n")
                f.write("# Auto-generated by consistency checker\n\n")
                for req in sorted(all_requirements):
                    f.write(f"{req}\n")
            
            # Backup and remove old files
            backup_dir = self.root_dir / ".consistency_backup"
            backup_dir.mkdir(exist_ok=True)
            
            for req_file in req_files:
                if req_file != root_req:
                    backup_path = backup_dir / req_file.name
                    shutil.copy2(req_file, backup_path)
                    req_file.unlink()
            
            self.fixes_applied.append(
                f"‚úÖ Consolidated {len(req_files)} requirements files (backups in .consistency_backup/)"
            )
        else:
            self.manual_actions.append(
                f"üìù Manually consolidate {len(req_files)} requirements files"
            )
    
    def create_env_example(self):
        """Create .env.example if it doesn't exist."""
        env_example = self.root_dir / ".env.example"
        env_file = self.root_dir / ".env"
        
        if env_example.exists():
            return  # Already exists
        
        if env_file.exists():
            if self.auto_fix or self._confirm("Create .env.example from .env?"):
                # Read .env and create sanitized example
                with open(env_file, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                
                with open(env_example, 'w', encoding='utf-8') as f:
                    f.write("# Environment variables example\n")
                    f.write("# Copy this file to .env and fill in your values\n\n")
                    
                    for line in lines:
                        if '=' in line and not line.strip().startswith('#'):
                            key = line.split('=')[0].strip()
                            f.write(f"{key}=your_{key.lower()}_here\n")
                        else:
                            f.write(line)
                
                self.fixes_applied.append("‚úÖ Created .env.example from .env")
            else:
                self.manual_actions.append("üìù Manually create .env.example")
        else:
            # Create basic template
            template = """# Environment variables example
# Copy this file to .env and fill in your values

# Database
DATABASE_URL=your_database_url_here

# API Keys
API_KEY=your_api_key_here

# Application
DEBUG=false
PORT=8000
"""
            if self.auto_fix or self._confirm("Create basic .env.example template?"):
                with open(env_example, 'w', encoding='utf-8') as f:
                    f.write(template)
                self.fixes_applied.append("‚úÖ Created .env.example template")
            else:
                self.manual_actions.append("üìù Manually create .env.example")
    
    def _confirm(self, message: str) -> bool:
        """Ask for user confirmation."""
        response = input(f"‚ùì {message} (y/n): ").lower().strip()
        return response == 'y'
    
    def print_summary(self):
        """Print summary of fixes applied."""
        print("\n" + "="*60)
        print("üéØ FIXES SUMMARY")
        print("="*60)
        
        if self.fixes_applied:
            print("\n‚úÖ Fixes Applied:")
            for fix in self.fixes_applied:
                print(f"  {fix}")
        else:
            print("\n‚úÖ No fixes needed or no fixes were approved")
        
        if self.manual_actions:
            print("\nüìù Manual Actions Required:")
            for action in self.manual_actions:
                print(f"  {action}")
        
        print("\n" + "="*60)


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: python fix_consistency.py <directory> [--auto]")
        print("Example: python fix_consistency.py /path/to/project")
        print("  --auto: Apply all fixes without prompting")
        sys.exit(1)
    
    root_dir = sys.argv[1]
    auto_fix = '--auto' in sys.argv
    
    if not os.path.isdir(root_dir):
        print(f"‚ùå Error: {root_dir} is not a valid directory")
        sys.exit(1)
    
    fixer = ConsistencyFixer(root_dir, auto_fix=auto_fix)
    fixer.fix_all()


if __name__ == "__main__":
    main()
